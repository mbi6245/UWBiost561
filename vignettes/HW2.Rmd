---
title: "HW2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{HW2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(bookdown)
library(tidyverse)
library(ggplot2)
country_population = readr::read_csv("https://raw.githubusercontent.com/linnykos/561_s2024_public/main/HW2_files/country_population.csv")
country_birth = readr::read_csv("https://raw.githubusercontent.com/linnykos/561_s2024_public/main/HW2_files/country_birth.csv")
penguins = readr::read_csv("https://raw.githubusercontent.com/linnykos/561_s2024_public/main/HW2_files/palmerpenguins.csv")
source("https://raw.githubusercontent.com/linnykos/561_s2024_public/main/HW2_files/random_graph_functions.R")
```

# Q1: 

## Part A

```{r}
# iso3c and country are both primary keys in this dataset
# after running summarize, only the grouped by columns and 
# the new column created within summarize will exist in the resulting dataframe
country_population %>% filter((1990 <= year) & (year <= 2010)) %>%
  group_by(iso3c, country) %>% 
  summarize(mean_population = mean(population))
```

## Part B

```{r}
country_birth %>% filter((1990 <= year) & (year <= 2010)) %>%
  dplyr::select(iso3c, year, life_expect) %>% 
  na.omit() %>% 
  group_by(iso3c) %>% 
  summarize(max_life_expect = max(life_expect),
            min_life_expect = min(life_expect)) %>% 
  mutate(range_life_expect = max_life_expect - min_life_expect)
```

# Part C

```{r}
country_both = inner_join(country_population, country_birth, by = "iso3c")
country_both
```

`country_both` has `r dim(country_both)` rows and columns, respectively in it.

\pagebreak

# Q2: 

## Part A

```{r}
p2a_plot = penguins %>%
  ggplot(aes(x = bill_depth_mm, y = bill_length_mm, color = species)) +
  geom_point() +
  scale_color_manual(values = c("Adelie" = "cornflowerblue", "Chinstrap" = "coral2", "Gentoo" = "goldenrod3")) +
  labs(x = "Bill Depth (mm)",
       y = "Bill Length(mm)", 
       title = paste("Relation Among", nrow(penguins), "Penguins"))

p2a_plot
```

```{r}
p2b_plot = penguins %>%
  ggplot(aes(x = bill_depth_mm, y = bill_length_mm, color = species)) +
  geom_point(alpha = 0.5) +
  scale_color_manual(values = c("Adelie" = "cornflowerblue", "Chinstrap" = "coral2", "Gentoo" = "goldenrod3")) +
  labs(x = "Bill Depth (mm)",
       y = "Bill Length(mm)", 
       title = paste("Relation Among", nrow(penguins), "Penguins")) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~ species)

p2b_plot
```

\pagebreak

# Problem 3

## Part A

```{r}
set.seed(0)
result <- generate_random_graph(n = 20,
                                clique_fraction = 0.5,
                                density_low = 0.1)
adj_mat <- result$adj_mat
dim(adj_mat)
adj_mat[1:5,1:5]
```

`generate_random_graph` first checks that the arguments provided by the user are valid, and then creates a random n by n matrix of 1s and 0s, with a density (i.e. proportion of nonzero entries) that the user can also specify. The matrix is then filled with a certain proportion of 1s in the top left, and the order of the entries is randomized again. Then, an array of reversed indices for the matrix is computed, and then both are returned by the function.

## Part B

```{r}
mat_long = pivot_longer_heatmap(adj_mat)
```


`pivot_longer_heatmap` then takes the matrix returned by `generate_random_graph` and then turns it into a long format. That is, the long format tibble returned by this function will have the original element's row and column indices in the first 2 rows, and then the value of the element at the corresponding original index (either 1 or 0) in the 3rd column.

## Part C

```{r}
ggplot(data = mat_long, mapping = aes(x = X, y = Y, fill = factor(Value))) +
  geom_tile() +
  scale_fill_manual(values = c("palegoldenrod", "coral2"), labels = c("0", "1")) +
  theme(aspect.ratio = 1) +
  labs(fill = "Value")
```

```{r}
adj_mat2 = result$adj_mat[result$rev_order, result$rev_order]
mat_long2 = pivot_longer_heatmap(adj_mat2)
ggplot(data = mat_long2, mapping = aes(x = X, y = Y, fill = factor(Value))) +
  geom_tile() +
  scale_fill_manual(values = c("palegoldenrod", "coral2"), labels = c("0", "1")) +
  theme(aspect.ratio = 1) +
  labs(fill = "Value")
```

This tells us that without reversing the order originally in the construction of the random matrix, the 1 values are heavily concentrated in the top left, which is given by the clique section of the code. Thus, `adj_mat2` is just the original matrix with the clique non reversed/intact, which is shown in the heatmap here.

# Problem 4

To ensure this teammate's function is correct, I would write a few test cases which which I could test the function. The first test case would be a clique density of 1, which would make the entire matrix a clique. I would then write a test case with 0 density, so no clique. Then, my last 2 test cases would just be some test cases of realistic data from adjacency matrices, so just some random values for the clique density between 0 and 1.
